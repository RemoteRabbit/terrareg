-- Generate configuration schema and validation from source code
-- This script analyzes config structures and creates JSON schema

local M = {}

-- Parse configuration structure from source code
local function parse_config_structure(filepath)
  local file = io.open(filepath, "r")
  if not file then
    return {}
  end

  local content = file:read("*all")
  file:close()

  local schema = {
    type = "object",
    properties = {},
    required = {},
    title = "Terrareg Configuration",
    description = "Configuration schema for terrareg.nvim",
  }

  local in_config = false

  for line in content:gmatch("[^\r\n]+") do
    -- Config structure detection
    if line:match("M%.config%s*=") then
      in_config = true
    elseif in_config and line:match("^%s*}") then
      in_config = false
    elseif in_config then
      -- Parse field definitions
      local field_name, field_value = line:match("^%s*([%w_]+)%s*=%s*(.+),?")
      if field_name and field_value then
        local field_schema = {
          description = "Configuration field: " .. field_name,
        }

        -- Determine type from default value
        if field_value:match("^true$") or field_value:match("^false$") then
          field_schema.type = "boolean"
          field_schema.default = field_value == "true"
        elseif field_value:match("^%d+$") then
          field_schema.type = "integer"
          field_schema.default = tonumber(field_value)
        elseif field_value:match("^%d*%.%d+$") then
          field_schema.type = "number"
          field_schema.default = tonumber(field_value)
        elseif field_value:match("^[\"'].*[\"']$") then
          field_schema.type = "string"
          field_schema.default = field_value:gsub("^[\"']", ""):gsub("[\"']$", "")
        elseif field_value:match("^{") then
          field_schema.type = "object"
          field_schema.properties = {}
        else
          field_schema.type = "any"
        end

        schema.properties[field_name] = field_schema
      end
    end

    -- Parse EmmyLua annotations for richer type info
    if line:match("@field%s+([%w_]+)%s+([%w%|%?]+)%s*(.*)") then
      local field_name, field_type, field_desc =
        line:match("@field%s+([%w_]+)%s+([%w%|%?]+)%s*(.*)")

      if schema.properties[field_name] then
        -- Enhance existing field
        schema.properties[field_name].description = field_desc

        -- Parse type
        if field_type:match("boolean") then
          schema.properties[field_name].type = "boolean"
        elseif field_type:match("string") then
          schema.properties[field_name].type = "string"
        elseif field_type:match("number") then
          schema.properties[field_name].type = "number"
        elseif field_type:match("table") then
          schema.properties[field_name].type = "object"
        end

        -- Check if optional
        if not field_type:match("%?") then
          table.insert(schema.required, field_name)
        end
      end
    end
  end

  return schema
end

-- Generate validation functions
local function generate_validation_code(schema)
  local lines = {}

  table.insert(lines, "-- Auto-generated configuration validation")
  table.insert(lines, "-- DO NOT EDIT - Generated by generate_config_schema.lua")
  table.insert(lines, "")
  table.insert(lines, "local M = {}")
  table.insert(lines, "")
  table.insert(lines, "--- Validate configuration against schema")
  table.insert(lines, "-- @param config table Configuration to validate")
  table.insert(lines, "-- @return boolean, string|nil Success status and error message")
  table.insert(lines, "function M.validate_config(config)")
  table.insert(lines, "  if type(config) ~= 'table' then")
  table.insert(lines, "    return false, 'Configuration must be a table'")
  table.insert(lines, "  end")
  table.insert(lines, "")

  -- Generate validation for each field
  for field_name, field_schema in pairs(schema.properties) do
    table.insert(lines, "  -- Validate " .. field_name)
    table.insert(lines, "  if config." .. field_name .. " ~= nil then")

    if field_schema.type == "boolean" then
      table.insert(lines, "    if type(config." .. field_name .. ") ~= 'boolean' then")
      table.insert(lines, "      return false, '" .. field_name .. " must be a boolean'")
      table.insert(lines, "    end")
    elseif field_schema.type == "string" then
      table.insert(lines, "    if type(config." .. field_name .. ") ~= 'string' then")
      table.insert(lines, "      return false, '" .. field_name .. " must be a string'")
      table.insert(lines, "    end")
    elseif field_schema.type == "number" or field_schema.type == "integer" then
      table.insert(lines, "    if type(config." .. field_name .. ") ~= 'number' then")
      table.insert(lines, "      return false, '" .. field_name .. " must be a number'")
      table.insert(lines, "    end")
    elseif field_schema.type == "object" then
      table.insert(lines, "    if type(config." .. field_name .. ") ~= 'table' then")
      table.insert(lines, "      return false, '" .. field_name .. " must be a table'")
      table.insert(lines, "    end")
    end

    table.insert(lines, "  end")
    table.insert(lines, "")
  end

  -- Check required fields
  for _, required_field in ipairs(schema.required) do
    table.insert(lines, "  if config." .. required_field .. " == nil then")
    table.insert(lines, "    return false, 'Required field " .. required_field .. " is missing'")
    table.insert(lines, "  end")
    table.insert(lines, "")
  end

  table.insert(lines, "  return true")
  table.insert(lines, "end")
  table.insert(lines, "")
  table.insert(lines, "--- Get default configuration")
  table.insert(lines, "-- @return table Default configuration")
  table.insert(lines, "function M.get_default_config()")
  table.insert(lines, "  return {")

  for field_name, field_schema in pairs(schema.properties) do
    if field_schema.default ~= nil then
      local default_val
      if field_schema.type == "string" then
        default_val = '"' .. field_schema.default .. '"'
      else
        default_val = tostring(field_schema.default)
      end
      table.insert(lines, "    " .. field_name .. " = " .. default_val .. ",")
    end
  end

  table.insert(lines, "  }")
  table.insert(lines, "end")
  table.insert(lines, "")
  table.insert(lines, "return M")

  return table.concat(lines, "\n")
end

-- Generate documentation for configuration
local function generate_config_docs(schema)
  local lines = {}

  table.insert(lines, "# Configuration Reference")
  table.insert(lines, "")
  table.insert(
    lines,
    "This document describes all available configuration options for terrareg.nvim."
  )
  table.insert(lines, "")
  table.insert(lines, "## Schema")
  table.insert(lines, "")
  table.insert(lines, "```json")

  -- Simple JSON schema representation
  local json_lines = {}
  table.insert(json_lines, "{")
  table.insert(json_lines, '  "type": "' .. schema.type .. '",')
  table.insert(json_lines, '  "title": "' .. schema.title .. '",')
  table.insert(json_lines, '  "description": "' .. schema.description .. '",')
  table.insert(json_lines, '  "properties": {')

  local prop_count = 0
  for _, _ in pairs(schema.properties) do
    prop_count = prop_count + 1
  end

  local current_prop = 0
  for field_name, field_schema in pairs(schema.properties) do
    current_prop = current_prop + 1
    table.insert(json_lines, '    "' .. field_name .. '": {')
    table.insert(json_lines, '      "type": "' .. field_schema.type .. '",')
    table.insert(json_lines, '      "description": "' .. field_schema.description .. '"')
    if field_schema.default ~= nil then
      if field_schema.type == "string" then
        table.insert(json_lines, '      "default": "' .. field_schema.default .. '"')
      else
        table.insert(json_lines, '      "default": ' .. tostring(field_schema.default))
      end
    end
    if current_prop < prop_count then
      table.insert(json_lines, "    },")
    else
      table.insert(json_lines, "    }")
    end
  end

  table.insert(json_lines, "  }")
  table.insert(json_lines, "}")

  table.insert(lines, table.concat(json_lines, "\n"))
  table.insert(lines, "```")
  table.insert(lines, "")

  -- Configuration options table
  table.insert(lines, "## Options")
  table.insert(lines, "")
  table.insert(lines, "| Option | Type | Default | Description |")
  table.insert(lines, "|--------|------|---------|-------------|")

  for field_name, field_schema in pairs(schema.properties) do
    local default_str = field_schema.default and tostring(field_schema.default) or "none"
    table.insert(
      lines,
      string.format(
        "| `%s` | %s | `%s` | %s |",
        field_name,
        field_schema.type,
        default_str,
        field_schema.description
      )
    )
  end

  table.insert(lines, "")
  table.insert(lines, "## Example Configuration")
  table.insert(lines, "")
  table.insert(lines, "```lua")
  table.insert(lines, "require('terrareg').setup({")

  for field_name, field_schema in pairs(schema.properties) do
    if field_schema.default ~= nil then
      local comment = " -- " .. field_schema.description
      if field_schema.type == "string" then
        table.insert(lines, "  " .. field_name .. ' = "' .. field_schema.default .. '",' .. comment)
      else
        table.insert(
          lines,
          "  " .. field_name .. " = " .. tostring(field_schema.default) .. "," .. comment
        )
      end
    end
  end

  table.insert(lines, "})")
  table.insert(lines, "```")

  return table.concat(lines, "\n")
end

-- Main function
local function generate_config_schema()
  local source_file = "lua/terrareg/init.lua"

  if vim.fn.filereadable(source_file) ~= 1 then
    print("❌ Source file not found: " .. source_file)
    return false
  end

  -- Parse schema
  local schema = parse_config_structure(source_file)

  -- Generate validation code
  local validation_code = generate_validation_code(schema)

  -- Generate documentation
  local config_docs = generate_config_docs(schema)

  -- Ensure directories exist
  vim.fn.mkdir("lua/terrareg", "p")
  vim.fn.mkdir("docs/generated", "p")

  -- Write validation module
  local validation_file = io.open("lua/terrareg/config_validation.lua", "w")
  if validation_file then
    validation_file:write(validation_code)
    validation_file:close()
    print("✅ Generated lua/terrareg/config_validation.lua")
  end

  -- Write documentation
  local docs_file = io.open("docs/generated/configuration.md", "w")
  if docs_file then
    docs_file:write(config_docs)
    docs_file:close()
    print("✅ Generated docs/generated/configuration.md")
  end

  -- Write JSON schema
  local json_file = io.open("docs/generated/config-schema.json", "w")
  if json_file then
    -- Simple JSON representation
    local json_content = vim.fn.json_encode(schema)
    json_file:write(json_content)
    json_file:close()
    print("✅ Generated docs/generated/config-schema.json")
  end

  return true
end

M.generate = generate_config_schema
M.parse_config_structure = parse_config_structure

-- If called directly
if ... == nil then
  generate_config_schema()
end

return M
